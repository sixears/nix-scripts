{-# OPTIONS_GHC -Wall #-}
{-# LANGUAGE MonadComprehensions #-}

-- XXX add ability to pass through arguments (as _1, _2, etc.?)
-- XXX add counter (thing incrementing; one per attempted match, one per successful match)
-- XXX add count of arguments
-- XXX add RE fn args pre-check ?
-- XXX Provide Printable of REPlacement; use it in logging (e.g., of std
--     replacement)

{-# LANGUAGE DeriveLift                 #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase                 #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE NoImplicitPrelude          #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE PatternSynonyms            #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE RankNTypes                 #-}
{-# LANGUAGE ScopedTypeVariables        #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TupleSections              #-}
{-# LANGUAGE TypeApplications           #-}
{-# LANGUAGE TypeFamilies               #-}
{-# LANGUAGE TypeSynonymInstances       #-}
{-# LANGUAGE UnicodeSyntax              #-}
{-# LANGUAGE ViewPatterns               #-}

import Base1T  hiding  ( toList )

-- base --------------------------------

import Data.List            ( nub )
import Data.List.NonEmpty   ( filter )
import Data.Maybe           ( catMaybes )
import GHC.Exts             ( toList )

-- containers --------------------------

import qualified  Data.Map.Strict  as  Map

-- containers-plus ---------------------

import ContainersPlus.Map  ( AsRepeatedKeyError( _RepeatedKeyError )
                           , RepeatedKeyError {-, fromList -} )

-- env-fpath ---------------------------

import Env.FPath  ( envRcAbsFile )

-- env-plus ----------------------------

import Env.Reader  ( runEnv )

-- fpath -------------------------------

import qualified FPath.Parseable

import FPath.AbsDir            ( AbsDir )
import FPath.AbsFile           ( AbsFile )
import FPath.AsFilePath        ( filepath )
import FPath.Dirname           ( dirname )
import FPath.File              ( File, FileAs( _File_ ) )
import FPath.Error.FPathError  ( AsFPathError( _FPathError ) )
import FPath.Parseable         ( readM )
import FPath.RelFile           ( relfile )

-- logging-effect ----------------------

import Control.Monad.Log  ( LoggingT, MonadLog
                          , Severity( Debug, Informational, Notice ) )

-- log-plus ----------------------------

import Log  ( Log, logIO, logIOT )

-- mockio-log --------------------------

import MockIO.Log          ( DoMock( NoMock ), HasDoMock, mkIOLMER )
import MockIO.IOClass      ( HasIOClass, IOClass( IOWrite ) )
import MockIO.MockIOClass  ( MockIOClass )

-- mockio-plus -------------------------

import MockIO.Directory  ( mkdir )
import MockIO.File       ( lfexists' )
import MockIO.OpenFile   ( readFileY )

-- monadio-plus ------------------------

import MonadIO.Base                  ( getArgs )
import MonadIO.Error.CreateProcError ( AsCreateProcError( _CreateProcError ) )
import MonadIO.Error.ProcExitError   ( AsProcExitError( _ProcExitError ) )
import MonadIO.FPath                 ( pResolve )
import MonadIO.FStat                 ( FExists( FExists, NoFExists ) )

-- optparse-applicative ----------------

import Options.Applicative.Builder  ( argument, eitherReader, flag, help, long
                                    , metavar, short, strOption )
import Options.Applicative.Types    ( Parser )

-- optparse-plus -----------------------

import OptParsePlus  ( parsecReader, parseNE, textualOption )

-- parsec ------------------------------

import qualified Text.Parsec.Error
import qualified Text.Parsec.Prim

import Text.Parsec.Pos    ( SourceName )
import Text.Parsec.Prim   ( Parsec, Stream )

-- parsec-plus -------------------------

import Parsec.Error  ( AsParseError( _ParseError ), ParseError( ParseError ) )
import ParsecPlus    ( Parsecable( parser, parsec ) )

-- parsers -----------------------------

import Text.Parser.Char         ( char, noneOf, spaces )
import Text.Parser.Combinators  ( eof, optional, try )

-- parser-plus -------------------------

import ParserPlus  ( stringMaybeDQuoted )

-- pcre --------------------------------

import PCRE              ( compRE, replace, replace1, replaceMany )
import PCRE.Error        ( AsREFnError( _REFnError )
                         , AsREGroupError( _REGroupError )
                         , REFnGroupError, REParseError
                         )
import PCRE.REPlacement  ( REPlacement( REPlacement ) )
import PCRE.ReplText     ( ReplText, repltext )

-- regex-with-pcre ---------------------

import Text.RE.PCRE.Text  ( RE, re )

-- stdmain -----------------------------

import StdMain             ( Overwrite( NoOverwrite, Overwrite )
                           , checkInputFiles, checkOutputFiles, stdMain
                           , throwUsageErrors
                           )
import StdMain.UsageError  ( AsUsageError( _UsageError )
                           , UsageParseFPProcIOError )

-- text --------------------------------

import Data.Text     ( pack, unlines )
import Data.Text.IO  ( putStrLn )

-- unix --------------------------------

import qualified  System.Posix.Files

--------------------------------------------------------------------------------

data MkDirs = MkDirs | NoMkDirs
  deriving (Eq,Show)

------------------------------------------------------------

data Quiet = NoQuiet | Quiet
  deriving (Eq,Show)

------------------------------------------------------------

data ReplacementOpt = ROptRepl   REPlacement
                    | ROptREName ùïã
                    | ROptFile1  File
                    | ROptFileN  File

------------------------------------------------------------

data Options = Options { _repl_opt ‚à∑ ReplacementOpt
                       , _inputs   ‚à∑ NonEmpty File
                       , _mkdirs   ‚à∑ MkDirs
                       , _overwr   ‚à∑ Overwrite
                       , _quiet    ‚à∑ Quiet
                       }

--------------------

inputs ‚à∑ Lens' Options (NonEmpty File)
inputs = lens _inputs (\ o is ‚Üí o { _inputs = is })

--------------------

repl_opt ‚à∑ Lens' Options ReplacementOpt
repl_opt = lens _repl_opt (\ o rp ‚Üí o { _repl_opt = rp })

--------------------

mkdirs ‚à∑ Lens' Options MkDirs
mkdirs = lens _mkdirs (\ o m ‚Üí o { _mkdirs = m })

--------------------

overwr ‚à∑ Lens' Options Overwrite
overwr = lens _overwr (\ o w ‚Üí o { _overwr = w })

--------------------

quiet ‚à∑ Lens' Options Quiet
quiet = lens _quiet (\ o q ‚Üí o { _quiet = q })

------------------------------------------------------------

parseReplText ‚à∑ Parser ReplText
parseReplText = argument parsecReader (metavar "REPLACEMENT")

parseRE ‚à∑ Parser RE
parseRE = argument (eitherReader (first toString ‚àò compRE @REParseError ‚àò pack))
                   (metavar "REGEX")

parseREPlacement ‚à∑ Parser REPlacement
parseREPlacement = REPlacement ‚ä≥ parseRE ‚äµ parseReplText

parseReplacementOpt ‚à∑ Parser ReplacementOpt
parseReplacementOpt =
    ROptRepl ‚ä≥ parseREPlacement
  ‚à§ ROptREName ‚ä≥ (pack ‚ä≥ strOption (—é [ short 'n', long "name", metavar "REName"
                                      , help "select this named RE from re file"
                                      ]))
  ‚à§ ROptFile1 ‚ä≥ (textualOption (—é [ short 'f', long "file1"
                                  , help "use 1 RE from this file" ]))
  ‚à§ ROptFileN ‚ä≥ (textualOption (—é [ short 'F', long "file-many"
                                  , help "use many REs from this file" ]))

parseOptions ‚à∑ Parser Options
parseOptions =
  Options ‚ä≥ parseReplacementOpt
          ‚äµ parseNE (argument readM (metavar "FILENAME"))
          ‚äµ flag NoMkDirs MkDirs (—é [ short 'M', long "mkdirs"
                                    , help "make missing directories" ])
          ‚äµ flag NoOverwrite Overwrite (—é [ short 'O', long "overwrite"
                                          , help "overwrite extant files" ])
          ‚äµ flag NoQuiet Quiet (—é [ short 'q', long "no-output"
                                  , help "don't output file moves" ])

------------------------------------------------------------

-- XXX monadio-plus
rename' ‚à∑ ‚àÄ Œµ Œ≥ Œ¥ Œº . (MonadIO Œº, HasCallStack, FileAs Œ≥, FileAs Œ¥,
                       AsIOError Œµ, MonadError Œµ Œº, HasCallStack) ‚áí
          Œ≥ ‚Üí Œ¥ ‚Üí Œº ()
rename' (review _File_ ‚Üí from) (review _File_ ‚Üí to) =
  liftIO $ System.Posix.Files.rename (from ‚´• filepath) (to ‚´• filepath)

----------------------------------------

-- XXX mockios-plus
rename ‚à∑ ‚àÄ Œµ Œ≥ Œ¥ œâ Œº .
         (MonadIO Œº, AsIOError Œµ, Printable Œµ, MonadError Œµ Œº, HasCallStack,
          MonadLog (Log œâ) Œº, Default œâ, HasIOClass œâ, HasDoMock œâ, FileAs Œ≥,
          FileAs Œ¥, Printable Œ≥, Printable Œ¥) ‚áí
         Severity ‚Üí Œ≥ ‚Üí Œ¥ ‚Üí DoMock ‚Üí Œº ()
rename sev from to =
  let msg = [fmt|renam '%T' ‚Üí '%T'|] from to
   in mkIOLMER sev IOWrite msg ùïπ () (rename' from to)

----------------------------------------

{- | A regex file contains a list of regular expressions, with their
     replacements.  It is line-oriented.

     Each line must be either:
     -) 3 (posibly multiple) tab-separated columns, being name,regex,replacement.
        The name must be a simple identifier ([[:alpha:]]([\w_]*).
        The names must be unique.
     -) A sequence of space/tab characters
     -) A comment, beginning with '#'.
 -}

pe ‚à∑ AsParseError Œµ ‚áí Text.Parsec.Error.ParseError ‚Üí Œµ
pe e = _ParseError # ParseError e callStack

parse ‚à∑ ‚àÄ Œµ Œ± œÉ œÑ Œ∑ . (AsParseError Œµ, MonadError Œµ Œ∑, Stream œÉ Identity œÑ) ‚áí
        Parsec œÉ () Œ± ‚Üí SourceName ‚Üí œÉ ‚Üí Œ∑ Œ±
parse p s t = either (throwError ‚àò pe) return $ Text.Parsec.Prim.parse p s t

parseRegexLine ‚à∑ ‚àÄ Œµ œÉ Œ∑ .
                 (Stream œÉ Identity ‚ÑÇ, Show œÉ, AsParseError Œµ, MonadError Œµ Œ∑) ‚áí
                 SourceName ‚Üí œÉ ‚Üí Œ∑ (ùïÑ (ùïã, REPlacement))
parseRegexLine =
  let spc = spaces ‚ã™ optional (char '#' ‚ã™ many (noneOf "\n"))
      namedREPl ‚à∑ Stream œÉ' Identity ‚ÑÇ ‚áí Parsec œÉ' Œæ (ùïã, REPlacement)
      namedREPl = (,) ‚ä≥ (pack ‚ä≥ stringMaybeDQuoted ‚ã™ many (char '\t')) ‚äµ parser
      parseLine ‚à∑ Stream œÉ Identity ‚ÑÇ ‚áí Parsec œÉ () (ùïÑ (ùïã,REPlacement))
      parseLine = try (ùïµ ‚ä≥ (namedREPl) ‚ã™ spc) ‚à§ (pure ùïπ ‚ä≥ spc)
  in
    parse (parseLine ‚ã™ eof)

parseRegexLineTests ‚à∑ TestTree
parseRegexLineTests =
  let checkN s =
        testCase s $ ùïΩ ùïπ @=? parseRegexLine @ParseError "test" (pack s)
      check ex s =
        testCase s $ ùïΩ (ùïµ ex) @=? parseRegexLine @ParseError "test" (pack s)
   in testGroup "parseRegexLine"
        [ checkN "", checkN "\t", checkN "\t  \t", checkN "  \t  "
        , check ("rep1_0",rep1_0) (—é [ "rep1_0\t\t${iggy}(fo+)${pop}(.ar)\t\""
                                     , ">>${pop}<< (${1}) [${0}]\"" ])
        , check ("rep3_3",rep3_3) (—é [ "rep3_3\t\"(?<=/)foo\\\\.*(.{3})\"\t\t"
                                     , "\"quux.${.title 1}/\"  # c" ])
        ]

----------------------------------------

-- XXX use parsecFileUTF8 ?
readRegexFile ‚à∑ (MonadIO Œº,
                 AsParseError Œµ, AsIOError Œµ, AsRepeatedKeyError ùïã Œµ,
                 Printable Œµ, MonadError Œµ Œº, HasCallStack,
                 Default œâ, HasIOClass œâ, HasDoMock œâ, MonadLog (Log œâ) Œº) ‚áí
                AbsFile ‚Üí Œº (Map.Map ùïã REPlacement)

readRegexFile fn = do
  let msg = [fmt|reading regexen from %T|]
  ls ‚Üê readFileY @_ @[ùïã] Informational (ùïµ $ msg) (return "") fn NoMock
  result ‚Üê case ls of
    ùïπ     ‚Üí return Map.empty
    ùïµ ls' ‚Üí fromList ‚àò catMaybes ‚ä≥ forM ls' (parseRegexLine (toString fn))
  forM_ (toList result)
        (\ (k,v) ‚Üí logIO Debug def $ [fmtT|read RE: %t:\t%w|] k v)
  return result

----------------------------------------

-- XXX Clean this up, including logging useful things
renameFile ‚à∑ ‚àÄ Œµ œâ Œº . (MonadIO Œº,
                        HasDoMock œâ, HasIOClass œâ, Default œâ,
                        MonadLog (Log œâ) Œº,
                        AsFPathError Œµ, AsREFnError Œµ, AsREGroupError Œµ,
                        AsIOError Œµ, AsParseError Œµ, AsRepeatedKeyError ùïã Œµ,
                        Printable Œµ, HasCallStack, MonadError Œµ Œº) ‚áí
             Options ‚Üí AbsFile ‚Üí Œº (AbsFile,AbsFile)
renameFile opts fn = do
  let simple_replace replacement = do
        logIOT Informational $ [fmt|checking %T against %w|] fn replacement
        replace replacement (toText fn) ‚â´ \ case
          ùïπ   ‚Üí logIOT Notice ([fmt|no replacement: %T|] fn) ‚™º return (fn, fn)
          ùïµ f ‚Üí do (fn,) ‚ä≥ FPath.Parseable.parse @AbsFile f

      log_regex_read f c = do
        n ‚Üê pResolve f
        res ‚Üê readRegexFile n
        logIOT Informational $ [fmt|checking %T against %s RE from %T|] fn c n
        return res

  logIO Debug def $ [fmtT|processing '%T'|] fn
  case opts ‚ä£ repl_opt of

    ROptRepl replacement ‚Üí simple_replace replacement

    ROptREName n         ‚Üí do
      -- XXX should allow -f here to mean "select regex from this file"
      regexen ‚Üê default_regexen_fn ‚â´ readRegexFile
      let no_such_re = [fmt|no such regex '%T' found in '%T'|] n fn
       in case n `Map.lookup` regexen of
            ùïµ replacement ‚Üí simple_replace replacement
            ùïπ             ‚Üí throwError $ userE no_such_re

    ROptFile1 f          ‚Üí do
      res ‚Üê log_regex_read f "1"
      replace1 (Map.toList res) (toText fn) ‚â´ \ case
        ùïπ ‚Üí return (fn, fn)
        ùïµ (x,g) ‚Üí do logIOT Debug $ [fmt|[1] %T ‚Üí %t (%w)|] fn g x
                     (fn,) ‚ä≥ FPath.Parseable.parse @AbsFile g

    ROptFileN f          ‚Üí do
      res ‚Üê log_regex_read f "*"
      replaceMany (Map.toList res) (toText fn) ‚â´ \ case
        ([], _) ‚Üí return (fn, fn)
        (xs,g) ‚Üí do logIOT Debug $ [fmt|[*] %T ‚Üí %t %w|] fn g xs
                    (fn,) ‚ä≥ FPath.Parseable.parse @AbsFile g

----------------------------------------

default_regexen_fn ‚à∑ ‚àÄ Œµ Œº .
                     (MonadIO Œº, AsIOError Œµ, AsFPathError Œµ,
                      HasCallStack, MonadError Œµ Œº) ‚áí
                     Œº AbsFile
default_regexen_fn =
  runEnv (envRcAbsFile "RENAME_REGEXEN" [relfile|.rename/default-regexen.txt|])

----------------------------------------

-- A note on -v messages:
--   -) x ‚Üí y is issued on stdout unless --quiet is given
--   -) default (Warning)
--   -) (Notice) show non-renamed files
--   -) (Informational) show replacement checks about to happen
--   -) (Debug)
myMain ‚à∑ ‚àÄ Œµ .
         (HasCallStack, Printable Œµ, AsUsageError Œµ, AsIOError Œµ,AsParseError Œµ,
          AsProcExitError Œµ, AsCreateProcError Œµ, AsFPathError Œµ, AsREFnError Œµ,
          AsRepeatedKeyError ùïã Œµ, AsREGroupError Œµ) ‚áí
         [ùïä] ‚Üí DoMock ‚Üí Options
       ‚Üí LoggingT (Log MockIOClass) (ExceptT Œµ IO) Word8
myMain args do_mock opts = do
  logIOT Debug $ [fmt|ARGS: %L|] args
  ins ‚à∑ NonEmpty AbsFile ‚Üê sequence $ pResolve ‚ä≥ opts ‚ä£ inputs

  input_errors ‚Üê checkInputFiles (toList ins)

  outputs ‚Üê filter (\ (i,o) ‚Üí i ‚â¢ o) ‚ä≥ sequence (renameFile opts ‚ä≥ ins)

  let outdirs   = nub $ [ f ‚ä£ dirname | (_,f) ‚Üê outputs ]
      d_exist d = lfexists' Informational FExists d NoMock
  outdir_es ‚à∑ [(AbsDir,FExists)] ‚Üê forM outdirs $ \ d ‚Üí (d,) ‚ä≥ d_exist d
  let make_dirs = nub [ d | (d,e) ‚Üê outdir_es
                          , NoFExists ‚â° e, MkDirs ‚â° opts ‚ä£ mkdirs ]
  usage_errors ‚Üê checkOutputFiles (snd ‚ä≥ outputs) make_dirs
                                  (opts ‚ä£ overwr)
  throwUsageErrors do_mock "not continuing with rename in presence of errors"
                   (input_errors ‚äï usage_errors)

  forM_ make_dirs (\ d ‚Üí mkdir Notice d 0750 do_mock)
  forM_ outputs $ \ (infn,outfn) ‚Üí when (infn ‚â¢ outfn) $ do
    when (NoQuiet ‚â° opts ‚ä£ quiet)$ liftIO (putStrLn $ [fmt|%T ‚Üí %T|] infn outfn)
    rename Notice infn outfn do_mock

  return $ if outputs ‚â° [] then 1 else 0

----------------------------------------

data RenameError = RE_UFPPIO_ERROR UsageParseFPProcIOError
                 | RE_REFNG_ERROR  REFnGroupError
                 | RE_RK_ERROR     (RepeatedKeyError ùïã)

_RE_UFPPIO_ERROR ‚à∑ Prism' RenameError UsageParseFPProcIOError
_RE_UFPPIO_ERROR = prism' (\ e ‚Üí RE_UFPPIO_ERROR e)
                          (\ case RE_UFPPIO_ERROR e ‚Üí ùïµ e; _ ‚Üí ùïπ)

_RE_REFNG_ERROR ‚à∑ Prism' RenameError REFnGroupError
_RE_REFNG_ERROR = prism' (\ e ‚Üí RE_REFNG_ERROR e)
                         (\ case RE_REFNG_ERROR e ‚Üí ùïµ e; _ ‚Üí ùïπ)

_RE_RK_ERROR ‚à∑ Prism' RenameError (RepeatedKeyError ùïã)
_RE_RK_ERROR = prism' (\ e ‚Üí RE_RK_ERROR e) (\ case RE_RK_ERROR e ‚Üí ùïµ e; _ ‚Üí ùïπ)

----------------------------------------

instance Exception RenameError

--------------------

instance Show RenameError where
  show (RE_UFPPIO_ERROR e) = show e
  show (RE_REFNG_ERROR  e) = show e
  show (RE_RK_ERROR     e) = show e

--------------------

instance Printable RenameError where
  print (RE_UFPPIO_ERROR e) = print e
  print (RE_REFNG_ERROR  e) = print e
  print (RE_RK_ERROR     e) = print e

--------------------

instance HasCallstack RenameError where
  callstack =
    let
      getter (RE_UFPPIO_ERROR e) = e ‚ä£ callstack
      getter (RE_REFNG_ERROR  e) = e ‚ä£ callstack
      getter (RE_RK_ERROR     e) = e ‚ä£ callstack
      setter (RE_UFPPIO_ERROR e) cs =
        RE_UFPPIO_ERROR (e & callstack ‚ä¢ cs)
      setter (RE_REFNG_ERROR  e) cs =
        RE_REFNG_ERROR (e & callstack ‚ä¢ cs)
      setter (RE_RK_ERROR     e) cs =
        RE_RK_ERROR (e & callstack ‚ä¢ cs)
    in
      lens getter setter

----------------------------------------

instance AsREGroupError RenameError where
  _REGroupError = _RE_REFNG_ERROR ‚àò _REGroupError

instance AsREFnError RenameError where
  _REFnError = _RE_REFNG_ERROR ‚àò _REFnError

instance AsFPathError RenameError where
  _FPathError  = _RE_UFPPIO_ERROR ‚àò _FPathError

instance AsCreateProcError RenameError where
  _CreateProcError  = _RE_UFPPIO_ERROR ‚àò _CreateProcError

instance AsIOError RenameError where
  _IOError = _RE_UFPPIO_ERROR ‚àò _IOError

instance AsProcExitError RenameError where
  _ProcExitError  = _RE_UFPPIO_ERROR ‚àò _ProcExitError

instance AsParseError RenameError where
  _ParseError = _RE_UFPPIO_ERROR ‚àò _ParseError

instance AsUsageError RenameError where
  _UsageError  = _RE_UFPPIO_ERROR ‚àò _UsageError

instance AsRepeatedKeyError ùïã RenameError where
  _RepeatedKeyError  = _RE_RK_ERROR ‚àò _RepeatedKeyError

------------------------------------------------------------

main ‚à∑ IO ()
main = do
  let progDesc = unlines [ "rename files per a regex."
                         , "Note that the regex always matches against an"
                         , "absolute filename; but only the matched portion is"
                         , "replaced.  Therefore it is common to use a positive"
                         , "look-behind assertion such as (?<=/) to anchor the"
                         , "match to the beginning of a directory; or even"
                         , "(?<=/)(?=[^/]+$) to match only the filename portion"
                         , "of each file."
                         ]
  getArgs ‚â´ (\ args ‚Üí stdMain progDesc parseOptions (myMain @RenameError args) args)

--------------------------------------------------------------------------------

------------------------------------------------------------
--                       test data                        --
------------------------------------------------------------

re1 ‚à∑ RE
re1 = [re|${iggy}(fo+)${pop}(.ar)|]
re3 ‚à∑ RE
re3 = [re|(?<=/)foo\.*(.{3})|]

repl0 ‚à∑ ReplText -- ">>${pop}<< (${1}) [${0}]"
repl0 = [repltext|>>${pop}<< (${1}) [${0}]|]

repl3 ‚à∑ ReplText
ùïΩ repl3 = parsec @ReplText @Parsec.Error.ParseError
                 ("repl3"‚à∑ùïã) ("quux.${.title 1}/"‚à∑ùïã)

rep1_0 ‚à∑ REPlacement -- s/${iggy}(fo+)${pop}(.ar)/>>${pop}<< (${1}) [${0}]/
rep1_0 = REPlacement re1 repl0

rep3_3 ‚à∑ REPlacement -- s/(?<=/)foo\.*(.{3})$/quux.${.title 1}\//
rep3_3 = REPlacement re3 repl3

----------------------------------------

tests ‚à∑ TestTree
tests = testGroup "parseReplacementText" [ parseRegexLineTests ]

--------------------

_test ‚à∑ IO ExitCode
_test = runTestTree tests

--------------------

_tests ‚à∑ ùïä ‚Üí IO ExitCode
_tests = runTestsP tests

_testr ‚à∑ ùïä ‚Üí ‚Ñï ‚Üí IO ExitCode
_testr = runTestsReplay tests

-- that's all, folks! ----------------------------------------------------------
